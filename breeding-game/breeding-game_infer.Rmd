---
title: "Breeding game: infer"
author: "Timoth√©e Flutre, Philippe Brabant, Jacques David"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
colorlinks: true
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: TRUE
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: TRUE
---

<!--
This R chunk is used to set up some options.
-->
```{r setup, include=FALSE}
R.v.maj <- as.numeric(R.version$major)
R.v.min.1 <- as.numeric(strsplit(R.version$minor, "\\.")[[1]][1])
if(R.v.maj < 2 || (R.v.maj == 2 && R.v.min.1 < 15))
  stop("requires R >= 2.15", call.=FALSE)

suppressPackageStartupMessages(library(knitr))
opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE, fig.align="center")
```


# Overview

* https://github.com/timflutre/atelier-prediction-genomique

* Copyright 2016-2018 INRA, Montpellier SupAgro, AgroParisTech

* License: [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)


# Set up the environment

This R chunk is used to assess how much time it takes to execute the R code in this document until the end:
```{r time_0}
t0 <- proc.time()
```

Load the packages:
```{r load_pkg}
suppressPackageStartupMessages(library(lattice))
suppressPackageStartupMessages(library(QTLRel))
suppressPackageStartupMessages(library(qqman))
suppressPackageStartupMessages(library(lme4))
suppressPackageStartupMessages(library(sommer))
suppressPackageStartupMessages(library(breedR))
suppressPackageStartupMessages(library(rrBLUP))
suppressPackageStartupMessages(library(rutilstimflutre))
stopifnot(compareVersion("0.156.4",
                         as.character(packageVersion("rutilstimflutre")))
          != 1)
```

Retrieve the directory paths:
```{r setup_dir}
root.dir <- "~/work2/atelier-prog-selection-2018/data"
setup <- getBreedingGameSetup(root.dir)
```


# Load all input files

## Phenotypes

* yield (trait1)

* quality (trait2)

* presence of disease symptoms (trait3=1)

Collection:
```{r}
f <- paste0(setup$init.dir, "/phenos_coll.txt.gz")
tools::md5sum(path.expand(f))
phenos <- read.table(f, header=TRUE)
phenos$year <- as.factor(phenos$year)
phenos$plot <- as.factor(phenos$plot)
str(phenos)
```

Controls:
```{r}
f <- paste0(setup$init.dir, "/phenos_controls.txt.gz")
tools::md5sum(path.expand(f))
phectls <- read.table(f, header=TRUE)
phectls$year <- as.factor(phectls$year)
phectls$plot <- as.factor(phectls$plot)
str(phectls)
```

## Genotypes and SNP coordinates

```{r}
f <- paste0(setup$init.dir, "/genos_subset-coll.txt.gz")
tools::md5sum(path.expand(f))
genos <- as.matrix(read.table(f, header=TRUE))
genos[1:3, 1:4]
snp.density <- "hd"
f <- paste0(setup$init.dir, "/snp_coords_", snp.density, ".txt.gz")
snp.coords <- read.table(f, header=TRUE, stringsAsFactors=FALSE)
stopifnot(nrow(snp.coords) == ncol(genos))
snp.coords <- snp.coords[colnames(genos),]
head(snp.coords)
```

## Truth

```{r}
f <- paste0(setup$truth.dir, "/p0.RData")
tools::md5sum(path.expand(f))
load(f)
```


# Explore the data

Years with the presence of the pathogen on the site:
```{r}
(years.patho <- as.character(unique(phenos$year[phenos$pathogen])))
```

Summarize each trait:
```{r}
summary(phenos$trait1)
summary(phenos$trait2)
summary(phenos$trait1 * phenos$trait2 / 1000)
table(phenos$trait3[phenos$pathogen])
table(phenos$trait3[phenos$pathogen])
```

* large variation for trait1 and trait2

* several varieties have no symptoms (trait3=0) the years with the pathogen, indicating that they are resistant

Plot the raw phenotypic data with no subsetting:
```{r}
hist(phenos$trait1, breaks="FD", main="trait 1", las=1)
hist(phenos$trait2, breaks="FD", main="trait 2", las=1)
```

Plot the raw phenotypic data, subsetting per year:
```{r}
boxplot(phenos$trait1 ~ phenos$year, las=1, main="trait 1", xlab="year",
        ylab="phenotypes")
abline(h=mean(phenos$trait1), lty=2)
boxplot(phenos$trait2 ~ phenos$year, las=1, main="trait 2", xlab="year",
        ylab="phenotypes")
abline(h=mean(phenos$trait2), lty=2)
```

* clear `year` effect on the mean of each trait, but same variance

Plot the raw phenotypic data of trait1 and trait2 vs trait3 for the years at which the pathogen was observed:
```{r, fig.width=14, fig.height=9}
par(mfrow=c(1,2))
plot(jitter(phenos$trait3[phenos$pathogen]), phenos$trait1[phenos$pathogen],
     xlab="trait3", ylab="trait1", las=1)
plot(jitter(phenos$trait3[phenos$pathogen]), phenos$trait2[phenos$pathogen],
     xlab="trait3", ylab="trait2", las=1)
```

* left plot: product yield (trait1) decreases strongly for individuals showing disease symptoms (trait3=1)

* right plot: product quality (trait2) doesn't change whether individuals have symptoms or not

Plot the raw phenotypic data of trait1 vs trait2:
```{r, fig.width=14, fig.height=9}
par(mfrow=c(1,2))
plot(phenos$trait1, phenos$trait2, xlab="trait1", ylab="trait2",
     main="All years", las=1)
plot(phenos$trait1[! phenos$pathogen], phenos$trait2[! phenos$pathogen],
     xlab="trait1", ylab="trait2", main="Years without pathogen", las=1)
```

## Raw data subsetted per year

```{r, eval=TRUE}
for(year in levels(phenos$year)){
  x <- phenos$trait1[phenos$year == year]
  y <- phenos$trait2[phenos$year == year]
  ## plot(x, y, xlab="trait1", ylab="trait2", las=1,
  ##      main=paste0(year, ifelse(year %in% years.patho, " (pathogen)", "")))
  ## abline(lm(y ~ x), col="red")
  ## legend("bottomright", legend=paste0("cor=", format(cor(x, y), digits=2)),
  ##        col="red", lty=1, bty="n")
  regplot(x, y, xlab="trait1", ylab="trait2",
          main=paste0(year, ifelse(year %in% years.patho, " (pathogen)", "")))
}
```

## Averaged data subsetted per year

```{r, eval=TRUE}
for(year in levels(phenos$year)){
  x <- droplevels(phenos[phenos$year == year, c("ind","trait1")])
  x <- tapply(x$trait1, list(x$ind), mean)
  x <- setNames(x, names(x))
  y <- droplevels(phenos[phenos$year == year, c("ind","trait2")])
  y <- tapply(y$trait2, list(y$ind), mean)
  y <- setNames(y, names(y))
  ## plot(x, y, xlab="trait1", ylab="trait2", las=1,
  ##      main=paste0(year, ifelse(year %in% years.patho, " (pathogen)", "")))
  ## abline(lm(y ~ x), col="red")
  ## legend("bottomright", legend=paste0("cor=", format(cor(x, y), digits=2)),
  ##        col="red", lty=1, bty="n")
  regplot(x, y, xlab="trait1 averaged per ind",
          ylab="trait2 averaged per ind",
          main=paste0(year, ifelse(year %in% years.patho, " (pathogen)", "")))
}
```


# Analysis of trait3

Extract the data of the latest year for which genotypes and phenotypes are available:
```{r}
last.year <- "2014"
dat <- droplevels(phenos[phenos$year == last.year,])
str(dat)
```

## Linear model

### Model fitting

```{r}
fit.i <- lm(formula=trait3 ~ 1 + ind, data=dat)
```

TODO

## Linear mixed model

### Model fitting

```{r}
fit.i <- lmer(formula=trait3 ~ 1 + (1|ind), data=dat, REML=FALSE)
```

TODO: check if presence of spatial heterogeneity?

### Model comparison

```{r}
AIC(fit.i)
BIC(fit.i)
```

### Model selection

```{r}
bestmod <- fit.i
```

### Diagnostics

Prepare to diagnose the best model:
```{r}
fit.all <- cbind(dat,
                 response=dat$trait3,
                 cond.res=residuals(bestmod),
                 scl.cond.res=residuals(bestmod) / sigma(bestmod),
                 fitted=fitted(bestmod))
ind.cond.mode <- ranef(bestmod, condVar=TRUE, drop=TRUE)$ind
var.ind.cond.mode <- setNames(attr(ind.cond.mode, "postVar"),
                              names(ind.cond.mode))
```

Check the homoscedasticity of the errors:
```{r}
low.bound.norm.95 <- qnorm(p=0.025, mean=0, sd=1, lower.tail=TRUE)
x.lim <- max(abs(fit.all$scl.cond.res), na.rm=TRUE)
plot(x=jitter(fit.all$scl.cond.res), y=jitter(fit.all$fitted), las=1,
     xlim=c(-x.lim, x.lim), main=paste0("trait3 in ", last.year))
abline(v=0, lty=2)
abline(v=c(low.bound.norm.95, abs(low.bound.norm.95)), lty=3)
```

Check the normality of the errors:
```{r}
shapiro.test(fit.all$scl.cond.res)
qqnorm(y=fit.all$scl.cond.res,
       main=paste0("trait3 in ", last.year, ": Normal Q-Q plot of scl.cond.res"))
qqline(y=fit.all$scl.cond.res, col="red")
```

Check the absence of outlying individuals:
```{r}
x.lim <- max(abs(ind.cond.mode))
par(mar=c(5,6,4,1))
plot(x=ind.cond.mode, y=1:length(ind.cond.mode),
     xlim=c(-x.lim, x.lim), main=paste0("trait3 in ", last.year),
     yaxt="n", ylab="")
axis(side=2, at=1:length(ind.cond.mode), labels=names(ind.cond.mode), las=1)
abline(v=0, lty=2)
idx <- which.max(ind.cond.mode)
text(x=ind.cond.mode[idx], y=idx, labels=names(idx), pos=2)
idx <- which.min(ind.cond.mode)
text(x=ind.cond.mode[idx], y=idx, labels=names(idx), pos=4)
```

Check the normality of the random variables:
```{r}
qqnorm(y=ind.cond.mode, main="Normal Q-Q plot of ind.cond.mode", asp=1)
qqline(y=ind.cond.mode, col="red")
```

Check the independence between errors and random variables:
```{r}
x.lim <- max(abs(fit.all$scl.cond.res))
dotplot(ind ~ scl.cond.res, data=fit.all,
        xlim=c(-x.lim, x.lim), main=paste0("trait3 in ", last.year),
        panel=function(x,y,...){
          panel.abline(v=0, lty=2)
          panel.abline(v=c(low.bound.norm.95, abs(low.bound.norm.95)), lty=3)
          panel.dotplot(x,y,...)
        })
```

### Inference

Estimate variance components by REML:
```{r}
bestmod <- lmer(formula=formula(bestmod),
                data=dat, na.action=na.exclude, REML=TRUE)
summary(bestmod)
```

Compute the confidence interval for variance components:
```{r}
prof <- stats::profile(fitted=bestmod, signames=FALSE)
(ci <- stats::confint(object=prof, level=0.95))
```

Retrieve the true causal SNP of trait3 to highlight it in the Manhattan plot:
```{r}
(true.qtl3 <- p0$trait3$qtn.id)
```

### QTL detection with GEMMA

Launch [GEMMA](https://github.com/xiangzhou/GEMMA) (better and quicker than QTLRel, but only on Linux), if available:
```{r, eval=TRUE}
if(file.exists(Sys.which("gemma"))){
  print(system.time(
      res3.gemma <- gemma(model="ulmm",
                          y=ind.cond.mode,
                          X=genos[names(ind.cond.mode),],
                          snp.coords=snp.coords,
                          ## chr.ids=snp.coords[true.qtl3, "chr"],
                          W=matrix(rep(1, length(ind.cond.mode))),
                          out.dir=setup$truth.dir,
                          task.id=paste0("asso-coll-", last.year),
                          clean="all", verbose=1)))
  tmp <- data.frame(BP=snp.coords[rownames(res3.gemma$tests), "pos"],
                    CHR=as.numeric(gsub("chr", "",
                                        snp.coords[rownames(res3.gemma$tests),
                                                   "chr"])),
                    P=res3.gemma$tests$p_wald,
                    SNP=rownames(res3.gemma$tests))
  print(best.snp <- as.character(tmp$SNP[which.min(tmp$P)]))
  print(tmp[tmp$SNP %in% c(true.qtl3, best.snp),])
  qqman::manhattan(x=tmp,
                   chrlabs=paste0("chr",
                                  sort(unique(as.numeric(gsub("chr", "",
                                                              snp.coords$chr))))),
                   main="GEMMA on BLUPs of trait3",
                   suggestiveline=FALSE, genomewideline=FALSE, highlight=true.qtl3)
  print(table(genos[names(ind.cond.mode), true.qtl3]))
  print(median(ind.cond.mode[genos[names(ind.cond.mode), true.qtl3] == 0]))
  print(median(ind.cond.mode[genos[names(ind.cond.mode), true.qtl3] == 2]))
  print(length(resist.varieties <- rownames(genos)[genos[names(ind.cond.mode),
                                                         true.qtl3] == 2]))

  betterSummary(phenos$trait1[phenos$year == last.year])
  betterSummary(phenos$trait1[phenos$year == last.year &
                              ! phenos$ind %in% resist.varieties])
  betterSummary(phenos$trait1[phenos$year == last.year &
                              phenos$ind %in% resist.varieties])

  boxplotCandidateQtl(y=ind.cond.mode,
                      X=genos[names(ind.cond.mode),],
                      snp=best.snp,
                      xlab=paste0("genotypes at ", best.snp),
                      ylab="BLUPs",
                      main="BLUPs of trait3",
                      show.points=TRUE)
}
```

### QTL detection with QTLRel

Launch QTLRel (if available):
```{r, eval=TRUE}
if(! file.exists(Sys.which("gemma"))){
  afs <- colMeans(genos) / 2
  A.mark <- genos %*% t(genos) / (2 * sum(afs * (1 - afs)))
  A.mark <- A.mark[names(ind.cond.mode), names(ind.cond.mode)]
  res3 <- list()
  res3$vc <- estVC(y=ind.cond.mode,
                   v=list(AA=A.mark, DD=NULL, HH=NULL,
                          AD=NULL, MH=NULL, EE=diag(length(ind.cond.mode))))
  idx.snps <- 1:ncol(genos)
  ## TODO: see how to specify the nb of threads
  ## TODO: scan only the chr with the causal SNP
  res3$scan <- scanOne(y=ind.cond.mode, gdat=genos[names(ind.cond.mode), idx.snps],
                       vc=res3$vc, test="F", numGeno=TRUE)
  stopifnot(all(names(res3$scan$p) == rownames(snp.coords)))
  tmp <- data.frame(BP=snp.coords$pos,
                    CHR=as.numeric(gsub("chr", "", snp.coords$chr)),
                    P=res3$scan$p,
                    SNP=rownames(snp.coords))
  print(best.snp <- as.character(tmp$SNP[which.min(tmp$P)]))
  print(tmp[tmp$SNP %in% c(true.qtl3, best.snp),])
  qqman::manhattan(x=tmp,
                   chrlabs=paste0("chr",
                                  sort(unique(as.numeric(gsub("chr", "",
                                                              snp.coords$chr))))),
                   main="QTLRel on BLUPs of trait3",
                   suggestiveline=FALSE, genomewideline=FALSE, highlight=true.qtl3)

  boxplotCandidateQtl(y=ind.cond.mode,
                      X=genos[names(ind.cond.mode),],
                      snp=best.snp,
                      xlab=paste0("genotypes at ", best.snp),
                      ylab="BLUPs",
                      main="BLUPs of trait3",
                      show.points=TRUE)
}
```


# Analysis of traits 1 and 2

## Truth

Look at the true genotypic values:
```{r}
colMeans(p0$G.A)
var(p0$G.A[,1])
var(p0$G.A[,2])
cor(p0$G.A[,1], p0$G.A[,2])
regplot(p0$G.A[,1], p0$G.A[,2], xlab="Breeding values of trait1",
        ylab="Breeding values of trait2")
```


## Separately

### Trait1

Predict genotypic BLUPs for trait1 by fitting different models:
```{r}
fit1.yi <- list(merMod=lmer(trait1 ~ 1 + year + (1|ind) + (1|year:ind),
                            data=phenos))
extractAIC(fit1.yi$merMod)
anova(fit1.yi$merMod)
as.data.frame(VarCorr(fit1.yi$merMod))
fit1.yi$ci <- confint.merMod(fit1.yi$merMod, level=0.95,
                             method="profile", oldNames=FALSE)
fit1.yi$ci[1:3,]

fit1.pi <- list(merMod=lmer(trait1 ~ 1 + pathogen + (1|ind) + (1|pathogen:ind),
                            data=phenos))
extractAIC(fit1.pi$merMod)
anova(fit1.pi$merMod)
as.data.frame(VarCorr(fit1.pi$merMod))
fit1.pi$ci <- confint.merMod(fit1.pi$merMod, level=0.95,
                             method="profile", oldNames=FALSE)
fit1.pi$ci[1:3,]

fit1.yi.nopath <- list(merMod=lmer(trait1 ~ 1 + year + (1|ind) + (1|ind:year),
                                   data=droplevels(phenos[! phenos$pathogen,])))
(vc1.yi.nopath <- as.data.frame(VarCorr(fit1.yi.nopath$merMod)))
vc1.yi.nopath[2, "vcov"] / (vc1.yi.nopath[2, "vcov"] + vc1.yi.nopath[3, "vcov"])
anova(fit1.yi.nopath$merMod)
fit1.yi.nopath$ci <- confint.merMod(fit1.yi.nopath$merMod, level=0.95,
                                    method="profile", oldNames=FALSE)
fit1.yi.nopath$ci[1:3,]

fit1.yi.path <- list(merMod=lmer(trait1 ~ 1 + year + trait3 + (1|ind),
                                 data=droplevels(phenos[phenos$pathogen,])))
(vc1.yi.path <- as.data.frame(VarCorr(fit1.yi.path$merMod)))
vc1.yi.path[1, "vcov"] / (vc1.yi.path[1, "vcov"] + vc1.yi.path[2, "vcov"])
anova(fit1.yi.path$merMod)
fit1.yi.path$ci <- confint.merMod(fit1.yi.path$merMod, level=0.95,
                                  method="profile", oldNames=FALSE)
fit1.yi.path$ci

fit1.y.t3.i <- list(merMod=lmer(trait1 ~ 1 + year + trait3 + (1|ind),
                                data=phenos))
extractAIC(fit1.y.t3.i$merMod)
anova(fit1.y.t3.i$merMod)
(vc1.y.t3.i <- as.data.frame(VarCorr(fit1.y.t3.i$merMod)))
vc1.y.t3.i[1, "vcov"] / (vc1.y.t3.i[1, "vcov"] + vc1.y.t3.i[2, "vcov"])
fit1.y.t3.i$ci <- confint.merMod(fit1.y.t3.i$merMod, level=0.95,
                                 method="profile", oldNames=FALSE)
fit1.y.t3.i$ci
```

Choose the best model, and check it:
```{r}
fit1 <- fit1.y.t3.i
summary(fit1$merMod)
hist(residuals(fit1$merMod) / sigma(fit1$merMod))
abline(v=c(-2,0,2), lty=2)
plot(residuals(fit1$merMod) / sigma(fit1$merMod), fitted(fit1$merMod))
abline(v=c(-2,0,2), lty=2)
blups1 <- setNames(ranef(fit1$merMod)$ind[,"(Intercept)"],
                   rownames(ranef(fit1$merMod)$ind))
cor(blups1, p0$G.A[,1])
regplot(p0$G.A[,1], blups1, xlab="Breeding values of trait1",
        ylab="BLUPs of breeding values of trait1")
```

### Trait2

Predict genotypic BLUPs for trait2:
```{r}
fit2.y.i <- list(merMod=lmer(trait2 ~ 1 + year + (1|ind), data=phenos))
anova(fit2.y.i$merMod)
(vc2.y.i <- as.data.frame(VarCorr(fit2.y.i$merMod)))
vc2.y.i[1, "vcov"] / (vc2.y.i[1, "vcov"] + vc2.y.i[2, "vcov"])
fit2.y.i$ci <- confint.merMod(fit2.y.i$merMod, level=0.95,
                              method="profile", oldNames=FALSE)
fit2.y.i$ci

fit2 <- fit2.y.i
summary(fit2$merMod)
hist(residuals(fit2$merMod) / sigma(fit2$merMod))
abline(v=c(-2,0,2), lty=2)
plot(residuals(fit2$merMod) / sigma(fit2$merMod), fitted(fit2$merMod))
abline(v=c(-2,0,2), lty=2)
blups2 <- setNames(ranef(fit2$merMod)$ind[,"(Intercept)"],
                   rownames(ranef(fit2$merMod)$ind))
cor(blups2, p0$G.A[,2])
regplot(p0$G.A[,2], blups2, xlab="Breeding values of trait2",
        ylab="BLUPs of breeding values of trait2")
```

### Compare BLUPs for both traits

Compare BLUPs for both traits:
```{r}
all(names(blups1) == names(blups2))
cor(blups1, blups2)
regplot(blups1, blups2, main="Univariate LMM",
        xlab="BLUPs of breeding values of trait1",
        ylab="BLUPs of breeding values of trait2")
```


## Jointly

TODO: try `breedR`

Remove known confounders for both traits simultaneously (slow):
```{r, eval=FALSE}
system.time(
    fit12 <- mmer(Y=phenos[, c("trait1", "trait2")],
                  X=model.matrix(~ 1 + year + trait3, phenos),
                  Z=list(ind=list(Z=model.matrix(~ -1 + ind, phenos),
                                  K=diag(nlevels(phenos$ind)))),
                  method="NR", REML=TRUE, MVM=TRUE))
summary(fit12)
mean(fit12$u.hat$ind[,1])
mean(fit12$u.hat$ind[,2])
var(fit12$u.hat$ind[,1])
var(fit12$u.hat$ind[,2])
cor(fit12$u.hat$ind[,1], fit12$u.hat$ind[,2])
regplot(fit12$u.hat$ind[,1], fit12$u.hat$ind[,2], main="Multivariate LMM",
        xlab="Expected breeding values of trait1",
        ylab="Expected breeding values of trait2")
```


# Appendix

```{r info}
t1 <- proc.time(); t1 - t0
print(sessionInfo(), locale=FALSE)
```
