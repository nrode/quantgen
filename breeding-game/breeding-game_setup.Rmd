---
title: "Breeding game: setup"
author: "Timoth√©e Flutre, Philippe Brabant, Jacques David"
date: "`r format(Sys.time(), '%d/%m/%Y %H:%M:%S')`"
colorlinks: true
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: TRUE
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: TRUE
---

<!--
This R chunk is used to set up important options and load required packages.
-->
```{r setup, include=FALSE}
R.v.maj <- as.numeric(R.version$major)
R.v.min.1 <- as.numeric(strsplit(R.version$minor, "\\.")[[1]][1])
if(R.v.maj < 2 || (R.v.maj == 2 && R.v.min.1 < 15))
  stop("requires R >= 2.15", call.=FALSE)

suppressPackageStartupMessages(library(knitr))
opts_chunk$set(echo=TRUE, warning=TRUE, message=TRUE, cache=FALSE, fig.align="center")
```


# Overview

* https://github.com/timflutre/atelier-prediction-genomique

* Copyright 2016-2017 INRA, Montpellier SupAgro, AgroParisTech

* License: [CC BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/)


# Set up the environment

This R chunk is used to assess how much time it takes to execute the R code in this document until the end:
```{r time_0}
t0 <- proc.time()
```

Load the packages:
```{r load_pkg}
library(rutilstimflutre)
library(RSQLite)
library(MASS)
## library(LDheatmap) # optionnal
```

Set up directories:
```{r setup_dir}
root.dir <- "~/work2/atelier-prog-selection-2018"
if(! dir.exists(root.dir))
  dir.create(root.dir)
shared.dir <- NULL #"~/Dropbox/atelier-prog-selection-2018"
setup <- setUpBreedingGame(root.dir=root.dir, shared.dir=shared.dir,
                           nb.breeders=4, lang="fr")
truth.dir <- setup$truth.dir
shared.dir <- setup$shared.dir
init.dir <- setup$init.dir
breeders <- setup$breeders
breeder.dirs <- setup$breeder.dirs
dbname <- setup$dbname
```


# Simulate haplotypes and genotypes

## Use the sequential coalescent with recombination

Nb of initial individuals:
```{r init_inds}
I <- 1000
ind.ids <- sprintf(fmt=paste0("ind%0", floor(log10(I))+1, "i"), 1:I)
```

Simulate haplotypes and genotypes of initial individuals:

* hyp: single pop

* hyp: no inter-chrom LD

* hyp: all chroms have the same length

* hyp: individuals are diploids

* scaling: measure time in units of 4 x N_e generations

```{r init_chrs}
nb.chrs <- 10
L <- 10^6     # chromosome length, in base pairs
mu <- 10^(-8) # neutral mutation rate in events / base / generation
(u <- mu * L) # neutral mutation rate in events / chrom / gen
c <- mu       # recomb rate in events / base / gen
(r <- c * L)  # recomb rate in events / chrom / gen
```

Simplest evolutionary scenario similar to real data from domesticated plants:
```{r evol_scenario}
##                             _____
##                            /
##       ____________________/      Nec
##                       _Neb_
##                       |    \_____
##            Nea        |
##                       |
##                       |
##       ________________|
##                       2   1      0
## time  <---------------+---+------+
Nea <- 5 * 10^4         # ancestral
Neb <- 10 * 10^2        # bottleneck
Nec <- Ne0 <- 5 * 10^3  # current
(theta <- 4 * Ne0 * u)  # scaled neutral mutation rate in events / chrom
(rho <- 4 * Ne0 * r)    # scaled recomb rate in events / chrom
T1 <- 8000
T2 <- T1 + 2000
(alpha <- - (4 * Ne0) / T1 * log(Neb / Ne0)) # exp growth rate from Nec to Neb
(cmd <- paste0("-eG ", T1/(4*Ne0), " ", alpha,
               " -eN ", T2/(4*Ne0), " ", Nea/Ne0))
```

Simulate genotypes via the coalescent:
```{r simul_geno_coalescent}
set.seed(65291)
f <- paste0(truth.dir, "/g0.RData")
if(! file.exists(f)){
  g0 <- simulCoalescent(nb.inds=I,
                        ind.ids=ind.ids,
                        nb.reps=nb.chrs,
                        pop.mut.rate=theta,
                        pop.recomb.rate=rho,
                        chrom.len=L,
                        other=cmd,
                        nb.pops=1,
                        get.trees=FALSE,
                        get.tmrca=FALSE,
                        rnd.choice.ref.all=FALSE,
                        verbose=1)
  save(g0, file=f)
} else
  load(f)
tools::md5sum(path.expand(f))
head(g0$snp.coords)
g0$haplos$chr1[1:4, 1:6]
g0$genos[1:2, 1:6]
```

## Look at (M)AFs, LD, A

Look at the AFs and MAFs:
```{r look_mafs}
afs <- estimSnpAf(X=g0$genos)
hist(x=afs, xlab="Allele frequency", ylab="Number of markers",
     main=paste0(ncol(g0$genos), " SNPs"), col="grey", border="white",
     las=1, breaks="FD")
mafs <- estimSnpMaf(X=g0$genos)
summary(mafs)
sum(mafs >= 0.01) # nb of non-rare SNPs
plotHistMinAllelFreq(maf=mafs,
                     main=paste0(length(mafs), " SNPs"))
plotHistMinAllelFreq(maf=mafs[mafs >= 0.01],
                     main=paste0(sum(mafs >= 0.01), " SNPs (MAF >= 0.01)"))
```

Look at some haplotypes:
```{r look_haplos}
plotHaplosMatrix(g0$haplos$chr1[sort(sample.int(nrow(g0$haplos$chr1), 100)),
                                mafs[1:ncol(g0$haplos$chr1)] >= 0.2])
## calcAvgPwDiffBtwHaplos(g0$haplos$chr1) # slow
```

Estimate and plot pairwise LD per chromosome:
```{r estim_plot_ld}
chr <- "chr1"
min.maf <- 0.2
min.pos <- 0
max.pos <- L
(length(snps.tokeep <- rownames(g0$snp.coords[mafs >= min.maf &
                                               g0$snp.coords$chr == chr &
                                               g0$snp.coords$pos >= min.pos &
                                               g0$snp.coords$pos <= max.pos,])))
## snps.tokeep <- snps.tokeep[sort(sample(snps.tokeep, 100))]
(nrow(ld <- estimLd(X=g0$genos[,snps.tokeep],
                    snp.coords=g0$snp.coords[snps.tokeep,],
                    use.ldcorsv=FALSE)))
summary(ld$cor2)
snp.dist <- distSnpPairs(snp.pairs=ld[, c("loc1","loc2")],
                         snp.coords=g0$snp.coords[snps.tokeep,])
plotLd(snp.dist,
       ## ld$cor2, estim="r2",
       sqrt(ld$cor2), estim="r",
       main=paste0(length(snps.tokeep), " SNPs with MAF >= ", min.maf,
                   " on ", chr),
       use.density=TRUE,
       span=1/20,
       sample.size=2*I,
       Ne=Ne0, c=c)
abline(v=500, lty=2)
## LDheatmap(gdat=cor(g0$genos[,snps.tokeep])^2,
##           genetic.distances=snp.dist, distances="physical",
##           title=paste0(length(snps.tokeep), " SNPs with MAF >= ", min.maf,
##                        " on ", chr),
##           add.map=FALSE, flip=FALSE)
```

Look at distances between consecutive SNPs:
```{r dist_btw_snps}
chr <- "chr3"
tmp <- distConsecutiveSnps(snp.coords=g0$snp.coords, only.chr=chr)
hist(tmp[[chr]], breaks="FD", xlab="in bp", las=1,
     main="Distances between consecutive SNPs")
abline(v=500, lty=2)
```

Thin SNPs:
```{r thin}
thin.snps <- thinSnps(method="coord", threshold=5*10^4,
                      snp.coords=g0$snp.coords[names(mafs)[mafs >= 0.1],])
length(thin.snps)
```

Estimate additive genomic relationships:
```{r estim_genrel}
A.vr <- estimGenRel(X=g0$genos[,thin.snps], method="vanraden1")
A <- A.vr
imageWithScale(z=A, main="Additive genomic relationships (A)")
inbred.coefs <- diag(A) - 1
summary(inbred.coefs) # compare to 0 if no inbreeding
hist(inbred.coefs, breaks="FD")
abline(v=0, lty=2, col="red")
coancestries <- A / 2
summary(diag(coancestries)) # compare to 0.5 for an outbred individual
hist(diag(coancestries), breaks="FD", xlim=c(0,1))
abline(v=0.5, lty=2, col="red")
summary(coancestries[upper.tri(coancestries)])
hist(coancestries[upper.tri(coancestries)], breaks="Sturges")
abline(v=0, lty=2, col="red")
```

## Choose SNPs for genotyping

Ascertain SNPs for the genotyping arrays (high and low density):

* hyp: mimick de novo sequencing of a few individuals

```{r ascertain_snps}
if(! file.exists(paste0(init.dir, "/snp_coords_hd.txt.gz"))){
  nb.inds.denovo <- 20
  nb.snps.hd <- 10*10^3
  nb.snps.ld <- 5*10^3
  subset.inds <- sort(sample(rownames(g0$genos), nb.inds.denovo))
  mafs.subset <- estimSnpMaf(g0$genos[subset.inds,])
  summary(mafs.subset)
  sum(mafs.subset >= 0.1)
  subset.snps <- list()
  subset.snps[["hd"]] <- sample(names(mafs.subset[mafs.subset >= 0.1]), nb.snps.hd)
  subset.snps[["ld"]] <- sample(subset.snps[["hd"]], nb.snps.ld)
  summary(mafs[subset.snps[["hd"]]])
  summary(mafs[subset.snps[["ld"]]])
  f <- paste0(init.dir, "/snp_coords_hd.txt.gz")
  write.table(x=g0$snp.coords[subset.snps[["hd"]],],
              file=gzfile(f), quote=FALSE,
              sep="\t", row.names=TRUE, col.names=TRUE)
  f <- paste0(init.dir, "/snp_coords_ld.txt.gz")
  write.table(x=g0$snp.coords[subset.snps[["ld"]],],
              file=gzfile(f), quote=FALSE,
              sep="\t", row.names=TRUE, col.names=TRUE)
} else{
  subset.snps <- list()
  f <- paste0(init.dir, "/snp_coords_hd.txt.gz")
  subset.snps[["hd"]] <- rownames(read.table(f))
  f <- paste0(init.dir, "/snp_coords_ld.txt.gz")
  subset.snps[["ld"]] <- rownames(read.table(f))
}
```

## Make lines

Make collection of lines via haplodiploidization:
```{r coll_lines}
f <- paste0(truth.dir, "/coll.Rdata")
if(! file.exists(f)){
  coll <- list()
  crosses <- data.frame(parent1=ind.ids,
                        parent2=NA,
                        child=sprintf(fmt=paste0("Coll%0", floor(log10(I))+1, "i"),
                                      1:I),
                        stringsAsFactors=FALSE)
  loc.crossovers <- drawLocCrossovers(crosses, sapply(g0$haplos, ncol))
  coll$haplos <- makeCrosses(g0$haplos, crosses, loc.crossovers)
  coll$genos <- segSites2allDoses(seg.sites=coll$haplos, ind.ids=crosses$child,
                                  snp.ids=colnames(g0$genos),
                                  rnd.choice.ref.all=FALSE)
  coll$snp.coords <- g0$snp.coords
  save(coll, file=f)
} else
  load(f)
tools::md5sum(path.expand(f))
```

Free some memory:
```{r free_mem_genos}
## sort(sapply(ls(),function(x){object.size(get(x))}), decreasing=TRUE)
rm(g0, ld, snp.dist, mafs, loc.crossovers, mafs.subset, crosses,
   coancestries, A, A.vr)
gc()
```


# Simulate phenotypes

Simulate phenotypes of initial lines:

* hyp: only 3 traits are considered

* hyp: trait 1 has additive infinitesimal genetic architecture (e.g. yield)

* hyp: trait 2 has additive infinitesimal genetic architecture (e.g. quality)

* hyp: for traits 1 and 2, all SNPs (even the rarest) have a non-zero effect

* hyp: traits 1 and 2 are negatively genetically correlated (i.e. pleiotropy)

* hyp: "year" effects are different for traits 1 and 2, with the same variance but no covariance between traits or plots

* hyp: errors are different for traits 1 and 2, with the same variance but no covariance between traits, plots or years

* hyp: pathogens present every three years

* hyp: trait 3 has a single, major QTL (e.g. resistance)

* hyp: "trait3=0" means "absence of symptoms" and, very likely, presence of the resistance allele (but the years with pathogen, some genotypes without the resistant allele may exceptionnally show no symptom)

* hyp: the causal SNP is on the low-density chip

* hyp: the resistance-confering allele is the minor one, but isn't too rare

* hyp: the resistance-confering allele has a dominant effect

## Generic preparation

Make data.frame for initial phenotypes given to players:
```{r init_pheno}
line.ids <- getIndNamesFromHaplos(coll$haplos)[1:(150 + (10-1) * 75)]
p0.df <- makeDfInitPhenos(nb.lines.per.year=150, nb.years=10,
                          nb.plots.per.line.per.year=2,
                          first.year=2005, line.ids)
head(p0.df)
str(p0.df)
```

Export genotypes for the players using high-density chip, but only for lines planted the last year:
```{r export_geno}
f <- paste0(init.dir, "/genos_coll-latest-year.txt.gz")
latest.year <- as.numeric(levels(p0.df$year)[nlevels(p0.df$year)])
subset.coll <- unique(as.character(p0.df$ind[p0.df$year == latest.year]))
write.table(x=coll$genos[subset.coll, subset.snps[["hd"]]],
            file=gzfile(f), quote=FALSE,
            sep="\t", row.names=TRUE, col.names=TRUE)
```

Thin to avoid LD between causal SNPs?
```{r choose_causal_snps}
## mafs <- estimSnpMaf(X=coll$genos[levels(p0.df$ind),])
## thin.snps <- thinSnps(method="coord", threshold=5*10^2,
##                       snp.coords=coll$snp.coords[names(mafs)[mafs >= 0.01],])
length(thin.snps <- colnames(coll$genos))
```

## Traits 1 and 2

Simulate the SNP effects for traits 1 and 2 jointly:
```{r simum_snp_effects_trait1_trait2}
set.seed(39452)
snp.effects12 <- simulSnpEffectsTraits12(snp.ids=thin.snps,
                                         sigma.beta2=c(trait1=10^(-5),
                                                       trait2=10^(-5)),
                                         prop.pleio=0.4, cor.pleio=-0.7)
```

Make phenotypes for traits 1 and 2 jointly:
```{r make_phenos_trait1_trait2}
p0 <- simulTraits12(dat=p0.df, mu=c(trait1=40, trait2=14),
                    sigma.alpha2=c(trait1=1.5^2, trait2=1^2),
                    X=coll$genos[levels(p0.df$ind), thin.snps],
                    Beta=snp.effects12$Beta,
                    h2=c(trait1=0.3, trait2=0.4))
regplot(p0$G.A[,1], p0$G.A[,2], xlab="p0$G.A[,1]", ylab="p0$G.A[,2]", las=1)
```

Do some visual checks:
```{r plots_phenos_trait1_trait2}
hist(p0$Y[,1], breaks="FD", las=1, col="grey", border="white")
boxplot(p0$Y[,1] ~ p0.df$year, las=1, main="p0$Y[,1]")
abline(h=mean(p0$Y[,1]), lty=2)
hist(p0$Y[,2], breaks="FD", las=1, col="grey", border="white")
boxplot(p0$Y[,2] ~ p0.df$year, las=1, main="p0$Y[,2]")
abline(h=mean(p0$Y[,2]), lty=2)
regplot(p0$Y[,1], p0$Y[,2], xlab="p0$Y[,1]", ylab="p0$Y[,2]", las=1)
plot(p0$Y[,1], p0$Y[,2], xlab="p0$Y[,1]", ylab="p0$Y[,2]", las=1, type="n")
for(j in 1:nlevels(p0.df$year)){
  year <- levels(p0.df$year)[j]
  idx <- p0.df$year == year
  points(p0$Y[idx,1], p0$Y[idx,2], col=j)
  abline(lm(p0$Y[idx,2] ~ p0$Y[idx,1]), col=j)
}
```

## Trait 3

Make the "pathogen" column:
```{r patho_years}
p0.df$pathogen <- FALSE
first.year <- as.numeric(levels(p0.df$year)[1])
(years.with.patho <- seq(from=first.year, by=3, length.out=4))
p0.df$pathogen[p0.df$year %in% years.with.patho] <- TRUE
```

Make trait 3:
```{r make_trait3}
p0$trait3 <- simulTrait3(dat=p0.df, X=p0$X, afs=p0$afs,
                         subset.snps=subset.snps[["ld"]],
                         prob.resist.no.qtl=0.02)
table(p0$trait3$y)
```

## Finalize

Fill "phenotype" data.frame for players:
```{r fill_pheno_players}
p0.df$trait1.raw <- p0$Y[,1]
p0.df$trait2 <- p0$Y[,2]
p0.df$trait3 <- p0$trait3$y
```

Adjust trait 1 for yield loss in case of pathogen presence:
```{r adjust_trai1}
p0$prop.yield.loss <- 0.2
p0.df$trait1 <- p0.df$trait1.raw
idx <- p0.df$pathogen & (p0.df$trait3 == 1)
p0.df$trait1[idx] <- (1 - p0$prop.yield.loss) * p0.df$trait1[idx]
hist(p0.df$trait1, breaks="FD", las=1, col="grey", border="white")
boxplot(p0.df$trait1 ~ p0.df$year, las=1, main="p0.df$trait1")
abline(h=mean(p0.df$trait1), lty=2)
regplot(p0.df$trait1, p0.df$trait2, xlab="p0.df$trait1", ylab="p0.df$trait2",
        las=1)
```

Save data:
```{r save_phenos}
f <- paste0(truth.dir, "/p0.RData")
save(p0, file=f)
tools::md5sum(path.expand(f))
```

Export "phenotype" data.frame for players:
```{r export_phenos}
f <- paste0(init.dir, "/phenos_coll.txt.gz")
write.table(x=p0.df[, -grep("raw", colnames(p0.df))],
            file=gzfile(f), quote=FALSE,
            sep="\t", row.names=FALSE, col.names=TRUE)
tools::md5sum(path.expand(f))
```


# Choose controls

At the end of the game, each breeder has to submit at least one new variety.
For them to be registered, they should be "better" than controls.
The controls are chosen so that they have:

* an "additive genotypic yield" among the 40% best lines,

* an "additive genotypic quality" above the mean of all lines,

* the resistant allele for some of them.

Retrieve the breeding values of each line in the collection:
```{r rank_genos}
BVs <- data.frame(trait1=p0$mu[1] + p0$G.A[,1],
                  trait2=p0$mu[2] + p0$G.A[,2],
                  trait3=! p0$X[, p0$trait3$qtn.id] %in% p0$trait3$resist.genos,
                  row.names=rownames(p0$X))
summary(BVs)
```

Identify potential controls:
```{r identify_potential_controls, eval=TRUE}
BVs <- BVs[order(BVs$trait1, decreasing=TRUE),]
length(idx1 <- 1:ceiling(0.4 * nrow(BVs)))
summary(BVs[idx1,])
length(idx2 <- which(BVs$trait2 >= mean(BVs$trait2)))
potential.controls <- BVs[intersect(idx1, idx2),]
summary(potential.controls)
```

Select five controls among them:
```{r choose_controls, eval=TRUE}
nb.controls <- 5
nb.ctls.resist <- 2
stopifnot(sum(potential.controls$trait3 == 0) >= nb.ctls.resist)
nb.ctls.sensitiv <- nb.controls - nb.ctls.resist
stopifnot(sum(potential.controls$trait3 != 0) >= nb.ctls.sensitiv)
length(pot.ctls.resist <- rownames(potential.controls)[potential.controls$trait3 == 0])
ctls.resist <- sample(pot.ctls.resist, nb.ctls.resist)
length(pot.ctls.sensitiv <- rownames(potential.controls)[potential.controls$trait3 != 0])
ctls.sensitiv <- sample(pot.ctls.sensitiv, nb.ctls.sensitiv)
controls <- c(ctls.resist, ctls.sensitiv)
BVs[controls,]
```

Plot how good they are compare to the rest of the collection:
```{r plot_controls_phenos}
plot(x=p0$mu[1] + p0$G.A[,1], y=p0$mu[2] + p0$G.A[,2], las=1, main="Controls")
abline(v=mean(p0$mu[1] + p0$G.A[,1]), h=mean(p0$mu[2] + p0$G.A[,2]), lty=2)
points(x=p0$mu[1] + p0$G.A[ctls.resist, 1],
       y=p0$mu[2] + p0$G.A[ctls.resist, 2],
       pch=19, col="green")
points(x=p0$mu[1] + p0$G.A[ctls.sensitiv, 1],
       y=p0$mu[2] + p0$G.A[ctls.sensitiv, 2],
       pch=17, col="green")
plot(x=p0.df$trait1, y=p0.df$trait2, main="Controls")
points(x=p0.df$trait1[p0.df$ind %in% ctls.resist],
       y=p0.df$trait2[p0.df$ind %in% ctls.resist],
       pch=19, col="green")
points(x=p0.df$trait1[p0.df$ind %in% ctls.sensitiv],
       y=p0.df$trait2[p0.df$ind %in% ctls.sensitiv],
       pch=17, col="green")
```

Save controls for the players:
```{r savel_controls, eval=TRUE}
f <- paste0(init.dir, "/temoins.txt")
write.table(x=controls, file=f, quote=FALSE, sep="\t", row.names=FALSE, col.names=FALSE)
```

Make and save phenotypes of controls in several plots from another site (hence with different "year" effects) the last few years to give a kind of reference to the players:
```{r phenos_controls, eval=TRUE}
nb.years.per.ctl <- 4
nb.plots.per.ctl <- 5
phectls.df <- NULL
for(j in 1:nb.years.per.ctl){
  year <- latest.year - nb.years.per.ctl + j
  phectl.df <- makeDfPhenos(ind.ids=controls,
                            nb.plots=rep(nb.plots.per.ctl, length(controls)),
                            year=year,
                            pathogen=ifelse((year - 2005) %% 3 == 0,
                                            TRUE, FALSE))
  phectl <- simulTraits12(dat=phectl.df, mu=p0$mu, sigma.alpha2=p0$sigma.alpha2,
                          X=p0$X[controls,], Beta=p0$Beta, h2=p0$h2, verbose=0)
  phectl$trait3 <- simulTrait3(dat=phectl.df, X=p0$X, qtn.id=p0$trait3$qtn.id,
                               resist.genos=p0$trait3$resist.genos,
                               prob.resist.no.qtl=p0$trait3$prob.resist.no.qtl,
                               verbose=0)
  phectl.df$trait1.raw <- phectl$Y[,1]
  phectl.df$trait2 <- phectl$Y[,2]
  phectl.df$trait3 <- phectl$trait3$y
  phectl.df$trait1 <- phectl.df$trait1.raw
  tmp <- (phectl.df$pathogen & as.logical(phectl.df$trait3))
  if(any(tmp))
    phectl.df$trait1[tmp] <- (1 - p0$prop.yield.loss) * phectl.df$trait1[tmp]
  phectl.df <- phectl.df[, -grep("raw", colnames(phectl.df))]
  print(summary(phectl.df))
  fout <- paste0(setup$init.dir, "/phenos_controls-", year, ".txt.gz")
  if(file.exists(fout))
    file.remove(fout)
  write.table(x=phectl.df, file=gzfile(fout), quote=FALSE,
              sep="\t", row.names=FALSE, col.names=TRUE)
  if(j == 1){
    phectls.df <- phectl.df
  } else
    phectls.df <- rbind(phectls.df, phectl.df)
}
regplot(phectls.df$trait1, phectls.df$trait2, xlab="phectls.df$trait1",
        ylab="phectls.df$trait2", las=1)
```

Free some memory:
```{r free_mem_phenos}
rm(p0)
gc()
```


# Set up database and example files

Create a database with a table for logging, as well as a table of plant material per breeder:
```{r setup_db}
db <- dbConnect(SQLite(), dbname=dbname)
dbListTables(db)
tbl <- "log"
if(tbl %in% dbListTables(db)){
  query <- paste0("DROP TABLE ", tbl)
  res <- dbGetQuery(conn=db, query)
}
query <- paste0("CREATE TABLE ", tbl,
                "(breeder TEXT",
                ", year INT",
                ", task TEXT",
                ", quantity INT",
                ", time TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL)")
res <- dbGetQuery(conn=db, query)
dbListFields(db, tbl)
for(breeder in breeders){
  tbl <- paste0("plant_material_", breeder)
  if(tbl %in% dbListTables(db)){
    query <- paste0("DROP TABLE ", tbl)
    res <- dbGetQuery(conn=db, query)
  }
  query <- paste0("CREATE TABLE ", tbl,
                  " (parent1 TEXT, parent2 TEXT, child TEXT PRIMARY KEY)")
  res <- dbGetQuery(conn=db, query)
}
dbListTables(db)
```

For each individual initially given to the players, save it into the table, and save its haplotypes into a file (slow, especially the first time):
```{r fill_table}
f <- paste0(truth.dir, "/coll.Rdata")
load(f)
ind.ids <- rownames(coll$genos)
tmp.ids <- gsub("Coll", "Ind", ind.ids) # dummy identifiers for the parent1's
for(i in 1:length(ind.ids)){
  ind.id <- ind.ids[i]
  ind <- list(haplos=getHaplosInd(haplos=coll$haplos, ind.name=ind.id))
  f <- paste0(truth.dir, "/", ind.id, "_haplos.RData")
  save(ind, file=f)
  for(breeder in breeders){
    fto <- paste0(truth.dir, "/", breeder, "/", ind.id, "_haplos.RData")
    if(! file.exists(fto))
      file.symlink(f, fto)
    tbl <- paste0("plant_material_", breeder)
    query <- paste0("INSERT INTO ", tbl, " VALUES",
                    "('", tmp.ids[i],
                    "', '", NA,
                    "', '", ind.id, "')")
    res <- dbGetQuery(conn=db, query)
  }
}
```

Make an example of a "plant material" file:
```{r ex_cross}
(plant.examples <- makeExamplePlantFile(init.dir))
```

Make an example of an "data" file:
```{r ex_data}
(data.examples <- makeExampleDataFile(init.dir))
```


# Appendix

```{r info}
t1 <- proc.time(); t1 - t0
print(sessionInfo(), locale=FALSE)
```
